#                                              周报（10.4——10.9）





## 1近期学习内容概要

###             c语言学习

###              git学习

###              PTA刷题

## 2实际完成任务

###               【1】c语言：

​                       1.学习了程序结构的基本知识，学习了全局变量、编译预处理、大程序结构的知识

​                       2.了解了头文件的格式，尝试自己在c语言项目中写了简单的头文件源代码以及相应函数，了解了c语                      言项目的结构。

​                    3.学习了按位运算的原理

​                    4.学习了两种特殊函数：指针函数  函数指针。相应typora笔记如下

# 笔记开始//本文将总结关于函数指针和指针函数的内容

##   概述

指针函数和函数指针是C语言里两个比较绕的概念。但是不仅面试题爱考，实际应用中也比较广泛。我对两个概念也比较模糊，特别是当指针函数、函数指针、函数指针变量、函数指针数组放在一块的时候，能把强迫症的人活活逼疯。

## 指针函数

###         0定义   

###        

​                 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示

​                  ret *func(args, ...);

​                  

###        1简单例子

                     # include <stdio.h>
                     include <stdlib.h>
    
    int * func_sum(int n)
    {
        if (n < 0)
        {
            printf("error:n must be > 0\n");
            exit(-1);
        }
        static int sum = 0;
        int *p = &sum；
        for (int i = 0; i < n; i++)
        {
            sum += i;
        }
        return p;
    }
    
    int main(void)
    {
        int num = 0;
        printf("please input one number:");
        scanf("%d", &num);
        int *p = func_sum(num); 
        printf("sum:%d\n", *p);
        return 0;
    }


上例就是一个指针函数的例子，其中，`int * func_sum(int n)`就是一个指针函数， 其功能十分简单，是根据传入的参数n，来计算从0到n的所有自然数的和，其结果通过指针的形式返回给调用方。

在`func_sum`中，变量`sum`使用的是静态局部变量

如果我们把指针函数的`sum`定义为普通的局部变量，会是什么结果呢？

```c
int * func_sum(int n)
{
    if (n < 0)
    {
        printf("error:n must be > 0\n");
        exit(-1);
    }
    int sum = 0;
    int *p = &sum;
    for (int i = 0; i < n; i++)
    {
        sum += i;
    }
    return p;
}

int main(void)
{
    int num = 0;
    printf("please input one number:");
    scanf("%d", &num);
    int *p = func_sum(num); 
    printf("sum:%d\n", *p);
    return 0;
}
```

此时结果就不正确了

为什么会出现上面的结果呢？
其实原因在于，一般的局部变量是存放于栈区的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。上面的示例中，在返回该指针后，立即访问，的确是得到了正确的结果，但这只是十分巧合的情况，如果我们等待一会儿再去访问该地址，很有可能该地址已经被其他的变量所占用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。
因此，在使用指针函数的时候，一定要避免出现**返回局部变量指针**的情况。
那么为什么用了static就可以避免这个问题呢？
原因是一旦使用了static去修饰变量，那么该变量就变成了静态变量。而静态变量是存放在数据段的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。
因此，还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。

### 2static与动态空间

  如果想要指针函数中指针所指的内容不在函数结束时被释放，可以用static与malloc两种方法

### 3应用

调用字符串函数，并用指针把函数中定义的新的数组的首地址传回main函数。

注意：只有指针函数可以传递指针





## 函数指针

### 0定义  

###        

与指针函数不同，**函数指针** 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。
我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，**函数指针就是指向代码段中函数入口地址的指针。**
其声明形式如下所示：ret (*p)(args, ...);

其中，`ret`为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args`为形参列表。其中p被称为函数指针变量 。

### 1初始化

与数组类似，在数组中，数组名即代表着该数组的首地址，函数也是一样，函数名即是该数组的入口地址，因此，函数名就是该函数的函数指针。
因此，我们可以采用如下的初始化方式：

函数指针变量 =  函数名;

### 2简单例子

```c
#include <stdio.h>

int max(int a, int b)
{
    return a > b ? a : b;
}

int main(void)
{
    int (*p)(int, int); //函数指针的定义
    //int (*p)();       //函数指针的另一种定义方式，不过不建议使用
    //int (*p)(int a, int b);   //也可以使用这种方式定义函数指针
    
    p = max;    //函数指针初始化

    int ret = p(10, 15);    //函数指针的调用
    //int ret = (*max)(10,15);
    //int ret = (*p)(10,15);
    //以上两种写法与第一种写法是等价的，不过建议使用第一种方式
    printf("max = %d \n", ret);
    return 0;
}

```

调用的时候，既可以直接使用函数指针调用，也可以通过函数指针所指向的值去调用。`(*p)`所代表的就是函数指针所指向的值，也就是函数本身，这样调用自然不会有问题。。

### 3为什么使用函数指针

如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）

### 4回调函数//笔记结束

函数指针的一个非常典型的应用就是**回调函数**

回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。
回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。
同样我们来看一个回调函数的例子：

​      

```c
#include<stdio.h>
#include<stdlib.h>

//函数功能：实现累加求和
int func_sum(int n)
{
        int sum = 0;
        if (n < 0)
        {
                printf("n must be > 0\n");
                exit(-1);
        }
        for (int i = 0; i < n; i++)
        {
                sum += i;
        }
        return sum;
}

//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数
int callback(int n, int (*p)(int))
{
        return p(n);
}

int main(void)
{
        int n = 0;
        printf("please input number:");
        scanf("%d", &n);
        printf("the sum from 0 to %d is %d\n", n, callback(n, func_sum));       //此处直接调用回调函数，而不是直接调用func_sum函数
        return 0;
}

```

上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数`callback`无需关心`func_sum`是怎么实现的，只需要去调用即可。
这样的好处就是，如果以后对求和函数有优化，比如新写了个`func_sum2`函数的实现，我们只需要在调用回调函数的地方将函数指针指向`func_sum2`即可，而无需去修改`callback`函数内部。



### 【2】git

1学习了git的发展历史 、git和代码托管中心的关系

2学习了基本的命令行操作，如:设置签名、vim文件创立及更改、文件提交、本地库文件版本进退。

部分笔记如下

![image-20211009131929762](C:\Users\zyp\AppData\Roaming\Typora\typora-user-images\image-20211009131929762.png)

## 3疑问

​      1关于数据的几种存储方式不太了解，比如对字符串指针指向的静态本地变量不太了解，要想了解代码中不同变量的存储地址应该学习哪方面知识。

​      2 c语言除了PTA有哪些好的刷题网站？（力扣感觉有点难）

​      3 指针字符串 和数组字符串存储字符串的方式有哪些不同，为什么指针字符串初始化之后不能再做修改。

